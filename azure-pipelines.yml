# ==========================================
# PIPELINE CI/CD para Node.js + React (o Vue si es el caso)
# ==========================================

trigger:
  branches:
    include:
      - dev
      - main

pool:
  vmImage: ubuntu-latest

variables:
  # Aseg√∫rate de que NODE_ENV est√© configurado para builds de producci√≥n
  NODE_ENV: production

stages:
# ======================
# 1Ô∏è‚É£ BUILD STAGE
# ======================
- stage: Build
  displayName: 'Build Stage'
  # NO HAY SECCI√ìN 'variables:' global aqu√≠ arriba
  jobs:
  - job: BuildJob
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '20.x'
      displayName: 'Install Node.js 20'

    # ... (task: NodeTool@0) ...

    - script: |
        node -v
        npm -v
        echo "--- Running npm install ---"
        # üëá Cambia de 'npm ci' a 'npm install'
        npm install 
        echo "--- npm install finished ---"
        echo "--- Running build ---"
        npx vite build 
      displayName: 'Install dependencies and build app'

# ... (task: PublishBuildArtifacts@1) ...

    - task: PublishBuildArtifacts@1
      # ... resto de la tarea ...
# ... resto del pipeline ...
      inputs:
        PathtoPublish: 'dist' # Aseg√∫rate que esta es la carpeta correcta de salida de Vite
        ArtifactName: 'drop'
      displayName: 'Publish build artifacts'

# ======================
# 2Ô∏è‚É£ TEST STAGE
# ======================
- stage: Test
  dependsOn: Build # Esta etapa depende de que el Build termine
  displayName: 'Test Stage' # Nombre de la etapa
  jobs:
  - job: TestJob # Nombre del trabajo dentro de la etapa
    steps: # Pasos a ejecutar en este trabajo
    # Instala Node.js para poder usar npm
    - task: NodeTool@0
      inputs:
        versionSpec: '20.x' # Versi√≥n de Node.js a usar
      displayName: 'Install Node.js 20 (for Test)' # Nombre de este paso

    # Paso para instalar dependencias y ejecutar las pruebas
    - script: |
        echo "--- Installing dependencies for tests ---"
        # Usa npm ci para instalar limpiamente bas√°ndose en package-lock.json
        # Esto instalar√° tanto dependencias normales como de desarrollo (devDependencies)
        npm ci
        echo "--- Running tests ---"
        # Ejecuta el script 'test' definido en tu package.json
        # Este comando debe estar configurado para correr tus pruebas y generar el reporte JUnit
        npm test
      displayName: 'Install Deps & Run Tests' # Nombre de este paso

    # Tarea separada para publicar los resultados de las pruebas
    - task: PublishTestResults@2
      displayName: 'Publish Test Results' # Nombre de este paso
      # condition: succeededOrFailed() # Publica si las pruebas pasan o fallan
      condition: always() # Publica siempre, sin importar el resultado de las pruebas
      inputs:
        # Formato del reporte que genera tu herramienta de pruebas
        testResultsFormat: 'JUnit'
        # Patr√≥n para encontrar los archivos de reporte. 'junit.xml' es com√∫n.
        # Ajusta si tu herramienta usa otro nombre como 'TEST-*.xml'
        testResultsFiles: '**/junit.xml'
        # Si es true, la tarea (y potencialmente el pipeline) fallar√° si alguna prueba falla.
        failTaskOnFailedTests: true

# ======================
# 3Ô∏è‚É£ DEPLOY STAGE
# ======================
- stage: Deploy
  dependsOn: Test
  condition: succeeded() # Solo desplegar si el Build y Test fueron exitosos
  displayName: 'Deploy Stage'
  jobs:
  - deployment: DeployWeb
    environment: 'staging' # Aseg√∫rate que este entorno existe en Azure DevOps
    strategy:
      runOnce:
        deploy:
          steps:
          # Descargar artefactos del build para desplegar
          - task: DownloadBuildArtifacts@1
            inputs:
              buildType: 'current'
              downloadType: 'single'
              artifactName: 'drop' # El artefacto del stage de Build
              downloadPath: '$(System.ArtifactsDirectory)/download'
            displayName: 'Download build artifacts for deployment'

          - script: |
              echo "Deploying files from $(System.ArtifactsDirectory)/download/drop"
              # Aqu√≠ ir√≠an los comandos reales para desplegar a tu servidor/servicio
              # EJEMPLO: az webapp deploy --resource-group <your-resource-group> --name <your-app-name> --src-path "$(System.ArtifactsDirectory)/download/drop"
              # O: scp -r "$(System.ArtifactsDirectory)/download/drop/*" user@your-server:/var/www/html/
              # O: rsync -avz "$(System.ArtifactsDirectory)/download/drop/" user@your-server:/var/www/html/
              # Reemplaza esta l√≠nea con tu l√≥gica de despliegue real:
              ls -R $(System.ArtifactsDirectory)/download/drop # Mantener esto para verificar el contenido del artefacto antes del despliegue real
              echo "Deployment successful!"
            displayName: 'Deploy to staging environment'
          # No necesitas volver a publicar artefactos aqu√≠ usualmente

# ======================
# 4Ô∏è‚É£ MONITOR STAGE (Opcional/Ejemplo)
# ======================
- stage: Monitor
  dependsOn: Deploy
  condition: succeeded()
  displayName: 'Monitor Stage'
  jobs:
  - job: MonitorJob
    steps:
    - script: |
        echo "--- Performing health check ---"
        # Reemplaza 'https://example.com' con la URL real de tu ambiente de staging
        curl -f -I https://your-staging-url.com || (echo "ERROR: Site unreachable or returned an error status" && exit 1)
        echo "Health check passed!"
      displayName: 'Check deployment health'
