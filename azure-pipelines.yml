# ==========================================
# PIPELINE CI/CD para Node.js + React (o Vue si es el caso)
# ==========================================

trigger:
  branches:
    include:
      - dev
      - main

pool:
  vmImage: ubuntu-latest

variables:
  # Asegúrate de que NODE_ENV esté configurado para builds de producción
  NODE_ENV: production

stages:
# ======================
# 1️⃣ BUILD STAGE
# ======================
- stage: Build
  displayName: 'Build Stage'
  # NO HAY SECCIÓN 'variables:' global aquí arriba
  jobs:
  - job: BuildJob
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '20.x'
      displayName: 'Install Node.js 20'

    - script: |
        # ... node -v, npm -v ...
        echo "--- Running npm ci ---"
        npm ci
        echo "--- npm ci finished ---"
        echo "--- Listing installed modules (checking for vite-plugin-pwa) ---"
        ls -l node_modules/vite-plugin-pwa || echo "vite-plugin-pwa NOT FOUND in node_modules"
        echo "--- Running build ---"
        npx vite build
      displayName: 'Install dependencies and build app'

    - task: PublishBuildArtifacts@1
      # ... resto de la tarea ...
# ... resto del pipeline ...
      inputs:
        PathtoPublish: 'dist' # Asegúrate que esta es la carpeta correcta de salida de Vite
        ArtifactName: 'drop'
      displayName: 'Publish build artifacts'

# ======================
# 2️⃣ TEST STAGE
# ======================
- stage: Test
  dependsOn: Build # Esta etapa depende de que el Build termine
  displayName: 'Test Stage' # Nombre de la etapa
  jobs:
  - job: TestJob # Nombre del trabajo dentro de la etapa
    steps: # Pasos a ejecutar en este trabajo
    # Instala Node.js para poder usar npm
    - task: NodeTool@0
      inputs:
        versionSpec: '20.x' # Versión de Node.js a usar
      displayName: 'Install Node.js 20 (for Test)' # Nombre de este paso

    # Paso para instalar dependencias y ejecutar las pruebas
    - script: |
        echo "--- Installing dependencies for tests ---"
        # Usa npm ci para instalar limpiamente basándose en package-lock.json
        # Esto instalará tanto dependencias normales como de desarrollo (devDependencies)
        npm ci
        echo "--- Running tests ---"
        # Ejecuta el script 'test' definido en tu package.json
        # Este comando debe estar configurado para correr tus pruebas y generar el reporte JUnit
        npm test
      displayName: 'Install Deps & Run Tests' # Nombre de este paso

    # Tarea separada para publicar los resultados de las pruebas
    - task: PublishTestResults@2
      displayName: 'Publish Test Results' # Nombre de este paso
      # condition: succeededOrFailed() # Publica si las pruebas pasan o fallan
      condition: always() # Publica siempre, sin importar el resultado de las pruebas
      inputs:
        # Formato del reporte que genera tu herramienta de pruebas
        testResultsFormat: 'JUnit'
        # Patrón para encontrar los archivos de reporte. 'junit.xml' es común.
        # Ajusta si tu herramienta usa otro nombre como 'TEST-*.xml'
        testResultsFiles: '**/junit.xml'
        # Si es true, la tarea (y potencialmente el pipeline) fallará si alguna prueba falla.
        failTaskOnFailedTests: true

# ======================
# 3️⃣ DEPLOY STAGE
# ======================
- stage: Deploy
  dependsOn: Test
  condition: succeeded() # Solo desplegar si el Build y Test fueron exitosos
  displayName: 'Deploy Stage'
  jobs:
  - deployment: DeployWeb
    environment: 'staging' # Asegúrate que este entorno existe en Azure DevOps
    strategy:
      runOnce:
        deploy:
          steps:
          # Descargar artefactos del build para desplegar
          - task: DownloadBuildArtifacts@1
            inputs:
              buildType: 'current'
              downloadType: 'single'
              artifactName: 'drop' # El artefacto del stage de Build
              downloadPath: '$(System.ArtifactsDirectory)/download'
            displayName: 'Download build artifacts for deployment'

          - script: |
              echo "Deploying files from $(System.ArtifactsDirectory)/download/drop"
              # Aquí irían los comandos reales para desplegar a tu servidor/servicio
              # EJEMPLO: az webapp deploy --resource-group <your-resource-group> --name <your-app-name> --src-path "$(System.ArtifactsDirectory)/download/drop"
              # O: scp -r "$(System.ArtifactsDirectory)/download/drop/*" user@your-server:/var/www/html/
              # O: rsync -avz "$(System.ArtifactsDirectory)/download/drop/" user@your-server:/var/www/html/
              # Reemplaza esta línea con tu lógica de despliegue real:
              ls -R $(System.ArtifactsDirectory)/download/drop # Mantener esto para verificar el contenido del artefacto antes del despliegue real
              echo "Deployment successful!"
            displayName: 'Deploy to staging environment'
          # No necesitas volver a publicar artefactos aquí usualmente

# ======================
# 4️⃣ MONITOR STAGE (Opcional/Ejemplo)
# ======================
- stage: Monitor
  dependsOn: Deploy
  condition: succeeded()
  displayName: 'Monitor Stage'
  jobs:
  - job: MonitorJob
    steps:
    - script: |
        echo "--- Performing health check ---"
        # Reemplaza 'https://example.com' con la URL real de tu ambiente de staging
        curl -f -I https://your-staging-url.com || (echo "ERROR: Site unreachable or returned an error status" && exit 1)
        echo "Health check passed!"
      displayName: 'Check deployment health'
